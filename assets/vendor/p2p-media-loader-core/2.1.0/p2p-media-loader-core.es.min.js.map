{"version":3,"file":"p2p-media-loader-core.es.min.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.22.0_rollup@4.27.3_vite@5.4.11_@types+node@22.9.1_terser@5.36.0_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js","../../../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/queue-tick@1.0.1/node_modules/queue-tick/queue-microtask.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/text-decoder@1.2.1/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.1/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.20.2/node_modules/streamx/index.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.11/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.8_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/peer.ts","../src/utils/version.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to, total } = contentRange;\n          if (\n            (total !== undefined && this.request.totalBytes !== total) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 5)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","export const PACKAGE_VERSION = \"2.1.0\";\n\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(\n  chunks: Uint8Array[],\n  totalBytes?: number,\n): Uint8Array {\n  if (totalBytes === undefined) {\n    totalBytes = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n  }\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${String(key)}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: Uint8Array,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    if (!this.commandChunks) {\n      this.commandChunks = new Command.BinaryCommandChunksJoiner(\n        (commandBuffer) => {\n          this.commandChunks = undefined;\n          const command = Command.deserializeCommand(commandBuffer);\n          this.eventHandlers.onCommandReceived(command);\n        },\n      );\n    }\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data as Uint8Array,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    const peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n    this._peers.clear();\n    this.logger(`destroy client; stream: ${this.streamShortId}`);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    } else if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      peerItem.potentialConnections.add(peerConnection);\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n      peerItem.potentialConnections.clear();\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker warning (${this.streamShortId}: ${warning})`);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker error (${this.streamShortId}: ${error})`);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const peer of this.trackerClient.peers()) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    if (!this.finalData) this.finalData = Utils.joinChunks(this.bytes);\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: this.segment,\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: this.segment,\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["RequestError","Error","type","message","super","this","timestamp","performance","now","CoreRequestError","HttpRequestExecutor","request","httpConfig","eventTarget","requestControls","abortController","AbortController","expectedBytesLength","requestByteRange","onChunkDownloaded","getEventDispatcher","byteRange","segment","loadedBytes","start","totalBytes","downloadSource","abort","notReceivingBytesTimeoutMs","httpNotReceivingBytesTimeoutMs","fetch","_a","_b","httpRequestSetup","url","signal","headers","Headers","Range","end","Request","aborted","DOMException","response","window","handleResponseHeaders","body","firstBytesReceived","reader","getReader","chunk","async","done","value","read","addLoadedChunk","byteLength","completeOnSuccess","error","handleError","ok","status","clearLoadedBytes","statusText","contentLengthHeader","get","contentRangeHeader","contentRange","headerValue","match","rangeHeaderRegex","exec","trim","from","to","total","parseInt","setTotalBytes","name","httpLoaderError","abortOnError","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","cachedSetTimeout","cachedClearTimeout","browser","exports","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","Item","array","noop","nextTick","args","Array","arguments","i","push","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","process$1","s","m","h","d","w","y","plural","ms","msAbs","n","isPlural","Math","round","val","options","str","String","parseFloat","toLowerCase","isFinite","long","abs","JSON","stringify","common","createDebug","namespace","prevTime","namespacesCache","enabledCache","enableOverride","debug","enabled","self","curr","Number","Date","diff","prev","coerce","unshift","index","replace","format","formatter","formatters","splice","formatArgs","log","useColors","color","selectColor","extend","destroy","defineProperty","enumerable","configurable","namespaces","set","v","init","delimiter","newDebug","toNamespace","regexp","toString","substring","default","stack","disable","names","map","skips","join","enable","save","split","RegExp","slice","test","humanize","require$$0","console","warn","keys","forEach","key","hash","charCodeAt","colors","load","module","c","lastC","storage","setItem","removeItem","r","getItem","DEBUG","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","firebug","exception","table","localStorage","localstorage","warned","j","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","eventsModule","emitter","Promise","resolve","reject","errorListener","err","resolver","eventTargetAgnosticAddListener","handler","flags","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","events","existing","warning","create","newListener","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","list","position","originalListener","shift","pop","rawListeners","eventNames","wrappy_1","wrappy","fn","cb","k","wrapper","f","called","onceStrict","onceError","onceModule","strict","proto","promise","queueMicrotask_1","queueMicrotask","global","then","catch","runParallel_1","tasks","results","pending","isSync","isArray","each","result","task","scope","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","FixedFIFO","hwm","buffer","mask","top","btm","next","clear","fill","data","last","isEmpty","browserDecoder","encoding","decoder","TextDecoder","remaining","decode","stream","flush","Uint8Array","PassThroughDecoder","UTF8Decoder","require$$1","STREAM_DESTROYED","queueTick","FIFO","head","tail","peek","MAX","NOT_OPENING","NOT_PREDESTROYING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_READ_AHEAD","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_PUSHED","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NOT_UPDATING","READ_NO_READ_AHEAD","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_FINISHING","WRITE_CORKED","WRITE_NON_PRIMARY","WRITE_NOT_NEXT_TICK","WRITE_NOT_CORKED","ACTIVE","READ_ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","DESTROYING","OPEN_STATUS","AUTO_DESTROY","ACTIVE_OR_TICKING","IS_OPENING","WRITE_QUEUED_AND_ACTIVE","WRITE_STATUS","asyncIterator","Symbol","WritableState","highWaterMark","mapWritable","byteLengthWritable","buffered","pipeline","drains","defaultByteLength","afterWrite","afterUpdateNextTick","updateWriteNT","_duplexState","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_open","afterOpen","_destroy","afterDestroy","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","ended","Pipeline","isStreamx","finished","onerror","onclose","afterDrain","write","drain","_read","READ_UPDATING","src","dst","afterPipe","pipeToFinished","updateCallback","rs","_readableState","ws","writes","Stream","opts","open","predestroy","_predestroy","destroyed","destroying","Readable","OPENING","eagerOpen","setEncoding","dec","echo","dest","pipe","resume","ite","return","readable","_fromAsyncIterator","promiseResolve","promiseReject","ondata","throw","Duplex","writev","final","uncork","batch","autoBatch","isStream","streamx","assign","obj","props","code","ErrClass","alphabet","encodeLookup","decodeLookup","arr2hex","string","hex2arr","sizeof","chars","lookup","arr2text","enc","encoder","TextEncoder","text2arr","encode","bin2hex","res","hex2bin","hex","points","fromCharCode","subarray","crypto","msCrypto","subtle","webkitSubtle","randomBytes","size","view","getRandomValues","Debug","MAX_BUFFERED_AMOUNT","filterTrickle","sdp","Peer","allowHalfOpen","_pc","__objectMode","objectMode","_id","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","trickle","allowHalfTrickle","iceCompleteTimeout","_destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","errCode","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","__destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","_setupData","channel","createDataChannel","ondatachannel","_needsNegotiation","_onFinishBound","_onFinish","bufferedAmount","connected","readyState","address","port","family","parse","renegotiate","transceiverRequest","addTransceiver","kind","candidate","remoteDescription","_addIceCandidate","setRemoteDescription","_createAnswer","iceCandidateObj","addIceCandidate","endsWith","send","negotiate","_createOffer","_senderMap","clearInterval","close","onmessage","onopen","ontrack","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","filename","lineno","colno","isClosing","setInterval","destroySoon","createOffer","offer","sendOffer","localDescription","setLocalDescription","createAnswer","answer","sendAnswer","_requestMissingTransceivers","connectionState","iceConnectionState","iceGatheringState","_maybeReady","flattenValues","report","values","getStats","reports","stat","id","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","ipAddress","portNumber","googLocalAddress","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","_onInterval","unref","signalingState","sender","removeTrack","sdpMLineIndex","sdpMid","_startIceCompleteTimeout","ArrayBuffer","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","UDPTracker","DEFAULT_ANNOUNCE_PEERS","MAX_ANNOUNCE_PEERS","parseUrl","URL","defineProperties","href","protocol","origin","_WebSocket","WebSocket","Socket","socket","_ws","OPEN","_handleOpen","_handleMessage","_handleClose","_handleError","_handleFinishBound","_handleFinish","onClose","CLOSED","_","WEBSOCKET_SUPPORT","Tracker","client","announceUrl","interval","intervalMs","DEFAULT_ANNOUNCE_INTERVAL","announce","_defaultAnnounceOpts","socketPool","WebSocketTracker","peers","reconnecting","retries","reconnectTimer","expectingResponse","_openSocket","params","action","info_hash","_infoHashBinary","peer_id","_peerIdBinary","_trackerId","trackerid","_send","numwant","min","_generateOffers","offers","scrape","infoHash","peerId","peer","trackerTimeout","_onSocketConnectBound","_onSocketDataBound","_onSocketCloseBound","_onSocketErrorBound","consumers","destroyCleanup","DESTROY_TIMEOUT","_onSocketConnect","_onSocketError","_onSocketData","_onSocketClose","parsedUrl","agent","_proxyOpts","httpsAgent","httpAgent","socksProxy","_onAnnounceResponse","_onScrapeResponse","failure","trackerId","complete","_createPeer","to_peer_id","offer_id","offerId","files","_startReconnectTimer","floor","random","pow","generateOffer","checkDone","_rtcConfig","wrtc","_wrtc","onError","onConnect","_socketPool","Client","_peerIdBuffer","_infoHashBuffer","_port","_getAnnounceOpts","getAnnounceOpts","rtcConfig","_userAgent","proxyOpts","isView","Set","webrtcSupport","nextTickWarn","_trackers","HTTPTracker","location","filter","Boolean","_announce","tracker","parallel","uploaded","downloaded","clientOpts","FF","a","b","GG","HH","II","bs","byte","wordToBytes","word","utf8toBytes","utf8","unescape","encodeURIComponent","md5Module","utf8toMD5","toHex","bytesToMD5","fromBytes","bytes","words","bytes_count","bits_count","Uint32Array","AA","BB","CC","DD","hash_bytes","substr","fromUtf8","b64","to64","u","charAt","b64_map","gen_salt","salt","crypt","setting","md","kl","TRACKER_CLIENT_VERSION_PREFIX","versionString","splittedVersion","padStart","HASH_SYMBOLS","getStreamString","getSegmentString","externalId","joinChunks","chunks","reduce","sum","offset","utf8ToUintArray","utf8String","encodeInto","arrayBackwards","isObject","deepCopy","element","overrideConfig","updates","defaults","updateValue","defaultValue","mergeAndFilterConfig","defaultConfig","baseConfig","specificStreamConfig","mergedConfig","keysOfT","filteredConfig","PeerCommandType","PeerCommandType2","SerializedItem","SerializedItem2","intToBytes","num","isNegative","bytesAmountNumber","binaryString","necessaryBits","ceil","bytesAmount","BigInt","bytesToInt","getNumberPart","number","serializeInt","numBytes","numberMetadata","deserializeInt","metadata","numberBytesLength","deserializeSimilarIntArray","codeByte","commonPartArraysAmount","originalIntArr","commonPartWithLength","arrayLength","commonPart","diffPart","numbers","deserializeString","lengthByte","stringBytes","ResizableUint8Array","_length","addBytes","bytesToAdd","getBuffer","commandFrameStart","stringToUtf8CodesBuffer","commandFrameEnd","commandDivFrameStart","commandDivFrameEnd","startFrames","endFrames","commandFramesLength","isCommandChunk","bufferEndingToCompare","some","frame","areBuffersEqual","BinaryCommandJoiningError","BinaryCommandChunksJoiner","onComplete","Serialization.ResizableUint8Array","isFirstChunk","unframeCommandChunk","BinaryCommandCreator","commandType","maxChunkLength","resultBuffers","Serialization.serializeInt","commonPartNumbersMap","Map","diffByte","binaryArray","getBytesChunks","unframedBuffer","frameBuffer","chunksCount","chunkLength","getResultBuffers","deserializeCommand","commandCode","deserializedCommand","getDataTypeFromByte","Serialization.SerializedItem","Int","Serialization.deserializeInt","SimilarIntArray","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","typeCode","Min","Max","frameStart","frameEnd","buffer1","buffer2","serializePeerCommand","command","maxChunkSize","CancelSegmentRequest","SegmentAbsent","SegmentDataSendingCompleted","creator","addInteger","SegmentRequest","SegmentsAnnouncement","p","loadingByHttp","l","loaded","addSimilarIntArr","SegmentData","PeerProtocol","connection","peerConfig","eventHandlers","commandChunks","uploadingContext","onChunkUploaded","onDataReceived","Command.isCommandChunk","receivingCommandBytes","onSegmentChunkReceived","idUtf8","binaryCommandBuffers","Command.serializePeerCommand","webRtcMaxMessageSize","stopUploadingSegmentData","stopUploading","getUploadingRequestId","requestId","splitSegmentDataToChunksAndUploadAsync","bytesLeft","bytesToSend","rej","t","isUploadingSegmentData","sendChunk","drained","Command.BinaryCommandChunksJoiner","commandBuffer","Command.deserializeCommand","onCommandReceived","addCommandChunk","Command.BinaryCommandJoiningError","Command","streamType","peerProtocol","downloadingContext","loadedSegments","httpLoadingSegments","downloadingErrors","logger","onPeerClosed","_c","onSegmentsAnnouncement","onSegmentRequested","isSegmentDataCommandReceived","controls","sendCancelSegmentRequestCommand","cancelSegmentDownloading","isValid","validateP2PSegment","delete","onPeerConnectionClosed","onConnectionError","getPeerIdFromConnection","has","segmentRequest","p2pNotReceivingBytesTimeoutMs","p2pErrorRetries","sendCommand","uploadSegmentData","sendSegmentDataSendingCompletedCommand","loadedSegmentsIds","httpLoadingSegmentsIds","segmentExternalId","hexString","isSafariOrWkWebview","isSafari","isWkWebview","P2PTrackerClient","streamSwarmId","streamShortId","_peers","onReceivePeerConnection","peerConnection","itemId","peerItem","potentialConnections","add","onPeerConnected","onTrackerClientWarning","onTrackerClientError","streamHash","streamId","binary15BytesHashString","md5","btoa","LoggerUtils.getStreamString","trackerClientVersionPrefix","trackerClientId","randomCharsCount","TrackerClient","announceTrackers","getStreamSwarmId","swarmId","getSegmentFromStreamsMap","streams","segmentRuntimeId","segments","getSegmentPlaybackStatuses","playback","timeWindowsConfig","currentP2PLoader","availableMemoryPercent","highDemandTimeWindow","httpDownloadTimeWindow","p2pDownloadTimeWindow","availableMemoryInPercent","isHighDemand","isSegmentInTimeWindow","isHttpDownloadable","isP2PDownloadable","isSegmentLoadingOrLoadedBySomeone","timeWindowLength","startTime","endTime","rate","P2PLoader","streamManifestUrl","requests","segmentStorage","onSegmentAnnouncement","trackerClient","isAnnounceMicrotaskCreated","isP2PUploadDisabled","httpLoading","getSegmentsAnnouncement","sendSegmentsAnnouncementCommand","broadcastAnnouncement","sendEmptyAnnouncement","sendSegmentsAnnouncement","byteFrom","sendSegmentAbsentCommand","StreamUtils.getStreamSwarmId","segmentData","getSegmentData","setSegmentChangeCallback","dispatchEvent","peersWithSegment","downloadingSegment","getSegmentStatus","getOrCreateRequest","downloadSegment","getStoredSegmentIds","httpRequests","runtimeId","P2PLoadersContainer","loaders","_currentLoaderItem","findOrCreateLoaderForStream","loader","loggerInfo","loaderItem","destroyTimeoutId","createLoader","setLoaderDestroyTimeout","destroyAndRemoveLoader","p2pInactiveLoaderDestroyTimeoutMs","Request$1","requestProcessQueueCallback","bandwidthCalculators","playbackConfig","currentAttempt","_failedAttempts","FailedRequestAttempts","finalData","_loadedBytes","_totalBytes","_status","progress","notReceivingBytesTimeout","_abortRequestCallback","_logger","_isHandledByProcessQueue","onSegmentError","onSegmentAbort","onSegmentStart","onSegmentLoaded","abortOnTimeout","throwErrorIfNotLoadingStatus","setStatus","manageBandwidthCalculatorsState","segmentUrl","bytesLength","restart","all","allBC","http","httpBC","lastLoadedChunkTimestamp","Timeout","Utils.joinChunks","failedAttempts","markHandledByProcessQueue","requestData","startFromByte","startTimestamp","_d","method","attempts","attempt","timeoutId","RequestsContainer","p2pRequests","abortFromProcessQueue","EngineRequest","engineCallbacks","_shouldBeStartedImmediately","bandwidth","onSuccess","markAsShouldBeStartedImmediately","generateQueue","lastRequestedSegment","availablePercentMemory","requestedSegment","queueSegments","first","firstStatuses","isNotActualStatuses","second","secondStatuses","statuses","HybridLoader","streamDetails","engineRequest","p2pLoaders","segmentAvgDuration","storageCleanUpIntervalId","levelChangedTimestamp","lastQueueProcessingTimeStamp","randomHttpDownloadInterval","isProcessQueueMicrotaskCreated","requestProcessQueueMicrotask","force","processQueue","activeStream","sumDuration","setIntervalLoading","peersCount","currentLoader","connectedPeerCount","randomTimeout","loadRandomThroughHttp","callbacks","LoggerUtils.getSegmentString","changeCurrentLoader","isLive","hasSegment","queueDownloadRatio","getBandwidth","queueSegmentIds","httpErrorRetries","isHandledByProcessQueue","remove","storeSegment","httpAttemptsCount","lastAttempt","processRequests","simultaneousHttpDownloads","simultaneousP2PDownloads","shouldBeStartedImmediately","executingHttpCount","loadThroughHttp","isP2PLoadingRequest","abortLastHttpLoadingInQueueAfterItem","executingP2PCount","loadThroughP2P","abortLastP2PLoadingInQueueAfterItem","isSegmentLoadedBySomeone","availableStorageCapacityPercent","getAvailableStorageCapacityPercent","p2pLoader","segmentsToLoad","QueueUtils.generateQueue","safeRandomSegmentsCount","randomIndices","probability","randomIndex","itemSegment","Utils.arrayBackwards","totalCapacity","usedCapacity","getUsage","maxPossibleLength","alreadyLoadedCount","activeLevelBitrate","getBandwidthLoadingOnly","max","httpRealBandwidth","sendEmptySegmentsAnnouncement","isRateChanged","isPositionChanged","isPositionSignificantlyChanged","onPlaybackUpdated","BandwidthCalculator","clearThresholdMs","loadingsCount","loadingOnlyTimestamps","timestamps","noLoadingsTime","loadingsStoppedAt","clearStale","seconds","ignoreThresholdTimestamp","NEGATIVE_INFINITY","milliseconds","lastItemTimestamp","lastCountedTimestamp","threshold","samplesToRemove","getStorageItemId","segmentId","BYTES_PER_MiB","SegmentMemoryStorage","segmentMemoryStorageLimit","currentStorageUsage","cache","coreConfig","mainStreamConfig","secondaryStreamConfig","currentPlayback","segmentChangeCallback","setMemoryStorageLimit","isLiveStream","o","_swarmId","storageId","increaseStorageUsage","segmentStorageId","dataItem","playbackPosition","calculatedUsedCapacity","externalIds","streamCacheId","newSegmentSize","isMemoryLimitReached","affectedStreams","sortedCache","sort","shouldRemoveSegment","decreaseStorageUsage","sendUpdatesToAffectedStreams","segmentByteLength","callback","currentPlaybackPosition","getStreamTimeWindow","isAndroid","configKey","EventTarget","eventName","definedListeners","indexOf","Core","static","manifestResponseUrl","commonCoreConfig","mainStreamLoader","secondaryStreamLoader","DEFAULT_COMMON_CORE_CONFIG","DEFAULT_STREAM_CONFIG","mainStream","secondaryStream","getConfig","dynamicConfig","mainStreamConfigCopy","secondaryStreamConfigCopy","overrideAllConfigs","processSpecificDynamicConfigParams","prevConfig","updatedConfig","isP2PDisabled","getUpdatedStreamProperty","destroyStreamLoader","streamLoader","sendBroadcastAnnouncement","propertyName","updatedStreamConfig","StreamUtils.getSegmentFromStreamsMap","streamRuntimeId","addSegments","removeSegmentIds","updateStream","initializeSegmentStorage","identifySegment","getStreamHybridLoader","loadSegment","abortSegmentRequest","updatePlayback","bitrate","notifyLevelChanged","createCustomStorage","customSegmentStorageFactory","initialize","createNewHybridLoader","streamConfig","_Ns"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}