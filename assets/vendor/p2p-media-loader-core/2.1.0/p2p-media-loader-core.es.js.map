{"version":3,"file":"p2p-media-loader-core.es.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.22.0_rollup@4.27.3_vite@5.4.11_@types+node@22.9.1_terser@5.36.0_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js","../../../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/queue-tick@1.0.1/node_modules/queue-tick/queue-microtask.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/text-decoder@1.2.1/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.1/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.20.2/node_modules/streamx/index.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.11/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.8_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/version.ts","../src/utils/peer.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to, total } = contentRange;\n          if (\n            (total !== undefined && this.request.totalBytes !== total) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 5)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","export const PACKAGE_VERSION = \"2.1.0\";\n\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(\n  chunks: Uint8Array[],\n  totalBytes?: number,\n): Uint8Array {\n  if (totalBytes === undefined) {\n    totalBytes = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n  }\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${String(key)}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: Uint8Array,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    if (!this.commandChunks) {\n      this.commandChunks = new Command.BinaryCommandChunksJoiner(\n        (commandBuffer) => {\n          this.commandChunks = undefined;\n          const command = Command.deserializeCommand(commandBuffer);\n          this.eventHandlers.onCommandReceived(command);\n        },\n      );\n    }\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data as Uint8Array,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    const peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n    this._peers.clear();\n    this.logger(`destroy client; stream: ${this.streamShortId}`);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    } else if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      peerItem.potentialConnections.add(peerConnection);\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n      peerItem.potentialConnections.clear();\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker warning (${this.streamShortId}: ${warning})`);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker error (${this.streamShortId}: ${error})`);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const peer of this.trackerClient.peers()) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    if (!this.finalData) this.finalData = Utils.joinChunks(this.bytes);\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: this.segment,\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: this.segment,\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["getDefaultExportFromCjs","browser","e","noop","browserExports","ms","require$$0","debug","self","common","exports","process","ReflectApply","ReflectOwnKeys","NumberIsNaN","EventEmitter","eventsModule","once","events","listeners","wrappy","cb","onceModule","queueMicrotask_1","global","queueMicrotask","scope","FixedFIFO","require$$1","TextDecoder","require$$2","require$$3","data","onerror","MAX_BUFFERED_AMOUNT","Duplex","errCode","err","event","Peer","Debug","ws","HTTPTracker","md5Module","i","md5","promise","encoder","decoder","obj","PeerCommandType","SerializedItem","Serialization.ResizableUint8Array","Serialization.serializeInt","Serialization.serializeSimilarIntArray","Serialization.serializeString","Serialization.SerializedItem","Serialization.deserializeInt","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","Command.isCommandChunk","Command.serializePeerCommand","Utils.getControlledPromise","Command.BinaryCommandChunksJoiner","Command.deserializeCommand","Command.BinaryCommandJoiningError","error","Utils.hexToUtf8","PeerUtil.getStreamHash","LoggerUtils.getStreamString","PeerUtil.generatePeerId","TrackerClient","StreamUtils.getSegmentFromStreamByExternalId","StreamUtils.getStreamSwarmId","peer","Utils.getRandomItem","Request","Utils.joinChunks","abort","StreamUtils.getSegmentAvgDuration","LoggerUtils.getSegmentString","queue","QueueUtils.generateQueue","Utils.shuffleArray","Utils.arrayBackwards","StreamUtils.getSegmentFromStreamsMap"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}